/*
 Name:		ESP32_RFID522_FIREBASE.ino
 Created:	27-Mar-22 11:36:30 AM
*/
/**
 * ----------------------------------------------------------------------------
 * This is a MFRC522 library example; see https://github.com/miguelbalboa/rfid
 * for further details and other examples.
 *
 * NOTE: The library file MFRC522.h has a lot of useful info. Please read it.
 *
 * Released into the public domain.
 * ----------------------------------------------------------------------------
 * Minimal example how to use the interrupts to read the UID of a MIFARE Classic PICC
 * (= card/tag).
 *duinojsonjsom
 * IRQ         ?            ?             ?         ?          2                10
 * SPI MOSI    MOSI         11 / ICSP-4   51        D11        ICSP-4           16
 * SPI MISO    MISO         12 / ICSP-1   50        D12        ICSP-1           14
 * SPI SCK     SCK          13 / ICSP-3   52        D13        ICSP-3           15
 *
 * More pin layouts for other boards can be found here: https://github.com/miguelbalboa/rfid#pin-layout
 *
 */

 //for time:
#include "time.h"
 // for firebase:
#include <ArduinoJson.hpp>
#include <ArduinoJson.h>
#include <WiFi.h>
#include <Firebase_ESP_Client.h>
#include <addons/TokenHelper.h>
/* 1. Define the WiFi credentials */
#define WIFI_SSID "Galaxy S20+dddc"//"NETGEAR98"//"The Promised LAN" //"Shirry's iPhone 12 Pro" //
#define WIFI_PASSWORD "akzp6337"//"coolfire180"//"SissoCatanMe0" // "bank4403" //
//#define WIFI_SSID "kh11"
//#define WIFI_PASSWORD "10203010"
/* 2. Define the API Key */
#define API_KEY "AIzaSyDVqDgltLIhBE6_KHj6jp337cB84uQmmbM"
/* 3. Define the project ID */
#define FIREBASE_PROJECT_ID "safetymanager-52fc3"
/* 4. Define the user Email and password that alreadey registerd or added in your project */
#define USER_EMAIL "iot.project.tns@gmail.com"
#define USER_PASSWORD "Iot123456"

#define MACHINE_ID "3"


// for RFID
#include <SPI.h>
#include <MFRC522.h>
#include "PCF8574.h"
#include <Wire.h>
#include "graphics.h"
#include "SPIFFS.h" 
#include <string>
PCF8574 pcf8574(0x21);
SPI_LCD_FrameBuffer lcd;

// for firebase:
// Define Firebase Data object
FirebaseData fbdo;
FirebaseAuth auth;
FirebaseConfig config;
bool taskCompleted = false;
unsigned long dataMillis = 0;

// for time:
const char* ntpServer = "pool.ntp.org";
const long  gmtOffset_sec = 0;
const int   daylightOffset_sec = 3600;

//for STOP button:
#define BUTTON_PIN 17

class ttgoCDacc : public lcdHwAccessor
{
public:
	ttgoCDacc() {};
	~ttgoCDacc() {};
	void setup()
	{
		pinMode(5, OUTPUT); //chip select
		pinMode(23, OUTPUT); //reset
		pinMode(4, OUTPUT); //Back Light
	}
	void reset()
	{
		digitalWrite(23, LOW);
		delay(250);
		digitalWrite(23, HIGH);
		delay(250);
	};
	void assertCS()
	{
		digitalWrite(5, LOW);
	}
	void deAssertCS()
	{
		digitalWrite(5, HIGH);
	}
	void backLightOn()
	{
		digitalWrite(4, HIGH);
	}
	void backLightOff()
	{

	}
} ttgoLCDaccessor;

extern SPIClass MFRC522spi;

#define RST_PIN         25           // Configurable, see typical pin layout above
#define SS_PIN          12           // Configurable, see typical pin layout above
#define IRQ_PIN         27           // Configurable, depends on hardware

MFRC522 mfrc522(SS_PIN, RST_PIN);   // Create MFRC522 instance.

MFRC522::MIFARE_Key key;

volatile bool bNewInt = false;
byte regVal = 0x7F;

void activateRec(MFRC522 mfrc522);
void clearInt(MFRC522 mfrc522);
void dump_byte_array(byte* buffer, byte bufferSize);
void readCard();

/**
 * Initialize.
 */
bool signupOK;

//ESPnow related:
#include "esp_now.h"
void OnDataSent(const uint8_t* mac_addr, esp_now_send_status_t status);
void OnDataRecv(const uint8_t* mac, const uint8_t* incomingData, int len);
uint8_t sonoffMACaddress[] = { 0x24, 0xA1, 0x60, 0x1D, 0x99, 0x03 }; // SonOff board - DC:4F:22:DE:ED:B1
String deviceMAC;
esp_now_peer_info_t peerInfo;
bool espNowPeerConnected = false, sendStatus = false, readWrite = false, recivedDataFlag = false;
bool sendDataBack(uint8_t* macAddress, char* dataToSend, unsigned int retryCounter);
unsigned int dataSent = 0;
#define USER_DATA_BUFFER_SIZE          32
#define START_OF_FRAME                                      '@'

char recivedData[USER_DATA_BUFFER_SIZE];
//espnow related:
// Callback when data is sent
void OnDataSent(const uint8_t* mac_addr, esp_now_send_status_t status)
{
	//Serial.println(status == ESP_NOW_SEND_SUCCESS ? "Deliverd Successfully" : "Delivery Failed");
				   //Serial.println(status == ESP_NOW_SEND_SUCCESS ? "Deliverd Successfully" : "Delivery Failed");
	if (status == ESP_NOW_SEND_SUCCESS)
	{
		espNowPeerConnected = true;
		dataSent = 1;
		sendStatus = true;
	}
	else
	{
		espNowPeerConnected = false;
		dataSent = 2;
		sendStatus = false;
	}
}

// Callback when data is received
void OnDataRecv(const uint8_t* mac, const uint8_t* incomingData, int len)
{
	unsigned int i = 0, startIndex = 0;
	while ((incomingData[startIndex] != START_OF_FRAME) && startIndex < len) startIndex++;
	if (startIndex == len)
	{
		return;
	}
	if (len > USER_DATA_BUFFER_SIZE)
	{
		len = USER_DATA_BUFFER_SIZE - 1;
	}
	if (incomingData[startIndex] == START_OF_FRAME) // Valid message 
	{
		for (i = startIndex; i < len; i++)
		{
			recivedData[i - 1] = incomingData[i];
		}
		recivedData[i - 1] = '\0';
		recivedDataFlag = true;
	}
}

bool sendDataBack(uint8_t* macAddress, char* dataToSend, unsigned int retryCounter)
{
	if (strlen(dataToSend) >= ESP_NOW_MAX_DATA_LEN)
		return false;
	for (size_t i = 0; i < retryCounter; i++)
	{
		dataSent = 0;
		esp_now_send(macAddress, (const unsigned char*)dataToSend, strlen(dataToSend));
		delay(100);
		if (dataSent == 1)
			return true;
	}
	return false;
}

void setup()
{
	Serial.begin(115200); // Initialize serial communications with the PC
	//while (!Serial);      // Do nothing if no serial port is opened (added for Arduinos based on ATMEGA32U4)
	delay(250);

	pcf8574.begin();

	if (!lcd.init(st7789_240x135x16_FB, &ttgoLCDaccessor, 16, 19, 18, 40000000))
	{
		printf("LCD init error\n");
		while (1);
	}

	MFRC522spi.begin(15, 36, 13, -1);          // Init SPI bus
	MFRC522spi.setFrequency(4000000);

	mfrc522.PCD_Init(); // Init MFRC522 card

	/* read and printout the MFRC522 version (valid values 0x91 & 0x92)*/
	Serial.print(F("Ver: 0x"));
	byte readReg = mfrc522.PCD_ReadRegister(mfrc522.VersionReg);
	Serial.println(readReg, HEX);

	/* setup the IRQ pin*/
	pinMode(IRQ_PIN, INPUT_PULLUP);

	/*
	 * Allow the ... irq to be propagated to the IRQ pin
	 * For test purposes propagate the IdleIrq and loAlert
	 */
	regVal = 0xA0; //rx irq
	mfrc522.PCD_WriteRegister(mfrc522.ComIEnReg, regVal);

	bNewInt = false; //interrupt flag

	/*Activate the interrupt*/
	attachInterrupt(digitalPinToInterrupt(IRQ_PIN), readCard, FALLING);

	/*do
	{ //clear a spourious interrupt at start
		;
	} while (!bNewInt);*/
	bNewInt = false;

	Serial.println(F("End setup"));

	// for firebase:
	  //  Serial.begin(115200);

	WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
	Serial.print("Connecting to Wi-Fi");
	while (WiFi.status() != WL_CONNECTED)
	{
		Serial.print(".");
		delay(300);
	}
	Serial.println();
	Serial.print("Connected with IP: ");
	Serial.println(WiFi.localIP());
	Serial.println();

	// for time:
	configTime(gmtOffset_sec, daylightOffset_sec, ntpServer);

	Serial.printf("Firebase Client v%s\n\n", FIREBASE_CLIENT_VERSION);

	/* Assign the api key (required) */
	config.api_key = API_KEY;

	/* Assign the user sign in credentials */
	auth.user.email = USER_EMAIL;
	auth.user.password = USER_PASSWORD;

	/* Assign the callback function for the long running token generation task */
	config.token_status_callback = tokenStatusCallback; // see addons/TokenHelper.h

	fbdo.setResponseSize(2048);
	if (Firebase.signUp(&config, &auth, "", "")) {
		Serial.println("ok");
		signupOK = true;
	}
	else {
		Serial.printf("%s\n", config.signer.signupError.message.c_str());
	}
	Firebase.begin(&config, &auth);

	//Firebase.reconnectWiFi(true);

	printf(" %d ", Firebase.ready());

	//espnow related:
	// Init ESP-NOW
	if (esp_now_init() != ESP_OK) {
		Serial.println("Error initializing ESP-NOW");
	}

	/* Callback Functions */
	// On Tx
	esp_now_register_send_cb(OnDataSent);
	// On Rx
	esp_now_register_recv_cb(OnDataRecv);

	/* Register peer */

	memset(&peerInfo, 0, sizeof(peerInfo));
	peerInfo.channel = 0;
	peerInfo.encrypt = false;

	memcpy(peerInfo.peer_addr, sonoffMACaddress, 6);
	// Add sonoff
	if (esp_now_add_peer(&peerInfo) != ESP_OK)
	{
		Serial.println("Failed to add sonoff");
	}
	
	//for button:
	pinMode(BUTTON_PIN, INPUT);
}

/**
 * Main loop.
 */
void loop()
{
	bool card = false;
	char tmpStr[14];
	lcd.loadFonts(ORBITRON_LIGHT24);
	lcd.setColor(255, 0, 0);
	int i, j;
	unsigned int ID;
	lcd.fillScr(255, 255, 255);
	lcd.print("Pass your card", 0, 135 / 2 - 24 / 2, true);
	lcd.flushFrameBuffer();

	while (1)
	{
		if (bNewInt)
		{ //new read interrupt
			Serial.print(F("Interrupt. "));
			mfrc522.PICC_ReadCardSerial(); //read the tag data
			// Show some details of the PICC (that is: the tag/card)
			Serial.print(F("Card UID:"));
			dump_byte_array(mfrc522.uid.uidByte, mfrc522.uid.size);
			Serial.println();
			lcd.fillScr(255, 255, 255);
			j = 0;
			for (i = 0; i < mfrc522.uid.size; i++)
			{
				sprintf(&tmpStr[j], "%02X", mfrc522.uid.uidByte[i]);
				j += 2;
			}
			tmpStr[j] = '\0';
			lcd.print(tmpStr, 0, 135 / 2 - 24 / 2, true);
			lcd.flushFrameBuffer();
			ID = strtol(tmpStr, (char**)NULL, 16);
			printf("Str: %s Card ID: %08X\n", tmpStr, ID);

			clearInt(mfrc522);
			mfrc522.PICC_HaltA();
			bNewInt = false;
			card = true;

			//handle ID 0 problem
			if (tmpStr == "") {
				card = false;
			}
		}
		// The receiving block needs regular retriggering (tell the tag it should transmit??)
		// (mfrc522.PCD_WriteRegister(mfrc522.FIFODataReg,mfrc522.PICC_CMD_REQA);)
		activateRec(mfrc522);
		delay(100);

		// for firebase:
		if (digitalRead(BUTTON_PIN) == LOW)
		{
			sendDataBack(sonoffMACaddress, "0", 10);
		}
		if (card && Firebase.ready())
		{
			if (!taskCompleted)
			{
				taskCompleted = true;

				// check if card_id is in the DB:
				char student_buffer[40];
				char student_col[] = "Students/";
				strcpy(student_buffer, student_col);
				strcat(student_buffer, tmpStr);

				if (Firebase.Firestore.getDocument(&fbdo, FIREBASE_PROJECT_ID, "", student_buffer)) {
					StaticJsonDocument<500> doc;

					// Deserialize the JSON document
					DeserializationError error = deserializeJson(doc, fbdo.payload().c_str());

					// Test if parsing succeeds.
					if (error) {
						Serial.print(F("deserializeJson() failed: "));
						Serial.println(error.f_str());
						return;
					}

					// Fetch value
					const char* student_perm_level = doc["fields"]["perm_level"]["stringValue"];
					Serial.printf("student_perm_level: %s\n\n", student_perm_level);

					//get machine data
					char machine_buffer[40];
					char machine_col[] = "Machines/";
					strcpy(machine_buffer, machine_col);
					strcat(machine_buffer, MACHINE_ID);

					const char* machine_perm_level;
					const char* machine_duration;
					if (Firebase.Firestore.getDocument(&fbdo, FIREBASE_PROJECT_ID, "", machine_buffer)) {
						// Deserialize the JSON document
						DeserializationError error = deserializeJson(doc, fbdo.payload().c_str());

						// Test if parsing succeeds.
						if (error) {
							Serial.print(F("deserializeJson() failed: "));
							Serial.println(error.f_str());
							return;
						}

						// Fetch values
						machine_perm_level = doc["fields"]["perm_level"]["stringValue"];
						machine_duration = doc["fields"]["duration"]["stringValue"];
						Serial.printf("machine_perm_level: %s\n\n", machine_perm_level);
						Serial.printf("machine_duration: %s\n\n", machine_duration);
					}
					else {
						Serial.printf("invalid Machine ID");
						return;
					}

					// check if student has permition for the machine
					int int_student_perm = 0;
					int int_machine_perm = 0;
					sscanf(student_perm_level, "%d", &int_student_perm);
					sscanf(machine_perm_level, "%d", &int_machine_perm);
					if (int_student_perm <= int_machine_perm) {
						Serial.printf("student has permission\n");
						//open sonoff for machine_duration time
						if (!sendDataBack(sonoffMACaddress, (char*)machine_duration, 10)) {
							printf("sonoff Error\n");

							//TODO: move to sonoff ok
							struct tm timeinfo;
							if (!getLocalTime(&timeinfo)) {
								Serial.println("Failed to obtain time");
								return;
							}

							char time_buffer[1000];
							sprintf(time_buffer, "%02d:%02d:%02d %02d/%02d/%02d", (timeinfo.tm_hour + 2) % 24, timeinfo.tm_min, timeinfo.tm_sec, timeinfo.tm_mday, timeinfo.tm_mon + 1, timeinfo.tm_year + 1900);
							Serial.println(time_buffer);

							// add to history
							char history_buffer[30];
							char history_col[] = "History";
							strcpy(history_buffer, history_col);

							FirebaseJson content;
							content.set("fields/card_id/stringValue", tmpStr);
							content.set("fields/machine_id/stringValue", MACHINE_ID);
							content.set("fields/time/stringValue", time_buffer);
							Serial.print("Create document... ");

							if (Firebase.Firestore.createDocument(&fbdo, FIREBASE_PROJECT_ID, "", history_buffer, content.raw()))
								Serial.printf("ok\n%s\n\n", fbdo.payload().c_str());
							else
								Serial.println(fbdo.errorReason());
						}
						else {
							printf("sonoff OK\n");
						}
					}
					else {
						Serial.printf("student does not have permission");
					}
				}
				// card_id does not exist
				else {
					struct tm timeinfo;
					if (!getLocalTime(&timeinfo)) {
						Serial.println("Failed to obtain time");
						return;
					}

					char time_buffer[1000];
					sprintf(time_buffer, "%02d:%02d:%02d %02d/%02d/%02d", (timeinfo.tm_hour + 2) % 24, timeinfo.tm_min, timeinfo.tm_sec, timeinfo.tm_mday, timeinfo.tm_mon + 1, timeinfo.tm_year + 1900);
					Serial.println(time_buffer);

					char registration_buffer[30];
					char registration_col[] = "Registration/";
					strcpy(registration_buffer, registration_col);
					strcat(registration_buffer, tmpStr);

					FirebaseJson content;
					content.set("fields/card_id/stringValue", tmpStr);

					content.set("fields/time/stringValue", time_buffer);
					Serial.print("Create document... ");

					if (Firebase.Firestore.createDocument(&fbdo, FIREBASE_PROJECT_ID, "", registration_buffer, content.raw()))
						Serial.printf("ok\n%s\n\n", fbdo.payload().c_str());
					else
						Serial.println(fbdo.errorReason());
				}
			}
		}
		taskCompleted = false;
		card = false;
	}
} //loop()

/**
 * Helper routine to dump a byte array as hex values to Serial.
 */
void dump_byte_array(byte* buffer, byte bufferSize)
{
	for (byte i = 0; i < bufferSize; i++)
	{
		Serial.print(buffer[i] < 0x10 ? " 0" : " ");
		Serial.print(buffer[i], HEX);
	}
}
/**
 * MFRC522 interrupt serving routine
 */
void readCard()
{
	bNewInt = true;
}

/*
 * The function sending to the MFRC522 the needed commands to activate the reception
 */
void activateRec(MFRC522 mfrc522)
{
	mfrc522.PCD_WriteRegister(mfrc522.FIFODataReg, mfrc522.PICC_CMD_REQA);
	mfrc522.PCD_WriteRegister(mfrc522.CommandReg, mfrc522.PCD_Transceive);
	mfrc522.PCD_WriteRegister(mfrc522.BitFramingReg, 0x87);
}

/*
 * The function to clear the pending interrupt bits after interrupt serving routine
 */
void clearInt(MFRC522 mfrc522)
{
	mfrc522.PCD_WriteRegister(mfrc522.ComIrqReg, 0x7F);
}
